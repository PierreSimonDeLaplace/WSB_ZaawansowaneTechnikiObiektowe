% Intro - luźne przemyślenia
%- Chcemy aby każdy członek zespołu stosował podobne zasady, wzorce i nazewnictwo. 
%- Wzorce i struktura są często dużo ważniejsze niż same algorytmy. 
%- Zazwyczaj temat wzorców projektowych, zasad SOLID, TDD czy refaktoringu pojawia się podczas rozmów kwalifikacyjnych. 
%- Wzorce i wspominane zasady SOLILD pozwalają odpoiwedzieć na pytanie jak podzielić projekt na niezależne komponenty, tak aby można było łatwo je rozszerzać i zamieniać, bez konieczności wprowadzania zmian z pozostałych komponentach. Dobry podział pozwala na szybsze znajdowanie błędów w oprogramowaniu. Jeżeli przepływ informacji jest prosty nie powinno być ciężko dowiedzieć się czy błąd znajduje się w warstwie logiki biznesowej, w kontrolerze czy widoku.
%- Z wzorcem Singleton może istnieć problem, że mamy dwa takie obiekty, które ze sobą rozmawiają. Przepływ informacji jest dwukierunkowy, który sprawia, że ciężej jest zrozumieć program i go debugować. Zazwyczaj zależy nam na jednokierunkowym przepływie informacji.
%- Obiekty modelu powinny zawierać jedynie takie zachowania, które bezpośrednio zmieniają ich stan. Nie powinny one zawierać logiki biznesowej.


\newtcolorbox{myboxWithTitle}[1]{colback=red!5!white,
	colframe=red!75!black,fonttitle=\bfseries,
	title={#1}}

\newtcolorbox{mybox}{colback=red!5!white,
	colframe=red!75!black}

\section{Zasady SOLID}

W publikacji \texttt{Design Principles and Design Patterns} Robert C. Martin opisał 5 zasad SOLID, które pomagają uzyskać lepszy, bardziej zrozumiały i łatwiejszy w utrzymaniu oraz rozbudowie kod. Są one również trzonem metodologi takich jak Agile czy programowanie adaptywne. W kolejnych podrozdziałach zostaną one po kolei opisane. %Niepożądane są tzw. ,,boskie klasy'' (ang. God classes), które są odpowiedzialne za wiele rzeczy. 

\subsection{SRP - Zasada pojedynczej odpowiedzialności (ang. \textbf{S}OLID)}

Pierwsza z pięciu zasad mówi, że każdy moduł, zestaw, klasa czy metoda powinna posiadać pojedynczy obszar odpowiedzialności (przyczynę zmian).  W momencie zmian wymagań, określa się jakie klasy są odpowiedzialne za dane wymagania i to te kasy się modyfikuje. Jeśli istnieją co najmniej dwa niezależne powody mogące wymusić zmianę w danej klasie, to dana klasa rozciąga się na więcej niż jeden obszar odpowiedzialności. W~przypadku naruszenia zasady SRP zmiany w dwóch różnych wymaganiach implikują modyfikację w jednej, tej samej klasie. 


\begin{myboxWithTitle}{Zasada pojedynczej odpowiedzialności}
	Żadna klasa nie może być modyfikowana z więcej niż jednego powodu.
\end{myboxWithTitle}

Wyobraźmy sobie sytuację, w której klasa rysująca figurę geometryczną na ekranie jest odpowiedzialna zarówno za wspomniane rysowanie, ale również za wyznaczanie pola powierzchni danej figury np. \texttt{Rectangle}. Jakie konsekwencje to za sobą niesie? Jeśli dwa zestawy np. interfejsu użytkownika \texttt{UI} oraz jakiś inny korzystający jedynie z operacji liczenia pola powierzchni będą związane z klasą \texttt{Rectangle} to zmiana wynikająca z wymagań związanych z \texttt{UI} może pociągać ryzyko nieprawidłowego działania w drugim zestawie. Chcąc zachować zasadę SRP należałoby stworzyć dwie osobne klasy: jedną rysująca figurę i drugą liczącą pole powierzchni. Pierwsza z~nich mogłaby wykorzystywać tę pierwszą. 

Oczywiście należy zawsze mieć na uwadze, że rozdrabniać klasy na coraz mniejsze typy można w~nieskończoność. Może to prowadzić do nadmiernego skomplikowania projektu. Konieczne jest branie pod uwagę wymagań i ich potencjalnych zmian.

Przeanalizujmy interfejs \texttt{IModem}.
\begin{lstlisting}[caption={Naruszenie zasady SRP}, label={lab1/lst/srpViolationModem}]
	public interface Modem
	{
		public void Dial(string phoneNumber);
		public void Hangup();
		public void Send(char c);
		public char Recieve();
	}
\end{lstlisting}
Widać, że interfejs posiada dwa obszary odpowiedzialności. Jeden odpowiada za nawiązywanie i zrywanie połączeń, drugi natomiast za same funkcje komunikacyjne. Tutaj konieczne jest przeanalizowanie wymagań, ponieważ podział interfejsu na dwa zawierające odpowiednio \texttt{Dial} i \texttt{Hangup} oraz \texttt{Send} i \texttt{Recieve} może nie być potrzebny, jeśli zmiany w aplikacji nie wpływają na zmiany w metodach zarządzających wykonywaniem połączeń.
% [DataChannel]^-.-[ModemImplementation]
% [Connection]^-.-[ModemImplementation]
%[<<interface>>;DataChannel|+send(c:char);+recv():char]
%[<<interface>>;Connection|+dial(pno: String);+hangup()]

\subsubsection{Zadanie 1}
\begin{lstlisting}[caption={Naruszenie zasady SRP}, label={lab1/lst/srpViolationEmployee}]
class Employee()
{
	public void CalculatePay();
	public void ReportHours();
	public void Store();
}
\end{lstlisting}
W powyższym przykładzie została naruszona zasada SRP, zaproponuj sposób rozdzielenia odpowiedzialności tej klasy. 
% Reguły biznesowe jak i mechanizmy wiedzialności nigdy nie powinny być ze sobą łączone. Powodu do ich zmian są różne. 
% Możemy powyższą klasę podzielić na trzy mniejsze klasy:
%\begin{itemize}
%	\item PayCalculator z metodą CalculatePay,
%	\item HourReporter z metodą ReportHours,
%	\item EmployeeRepository z metodą SaveEmployee.
%\end{itemize}
%Każda z tych klas może korzystać z encji \texttt{Employee}. 

% Inny przykład z Adaptive Code:
% klasa czytała dane ze strumienia, prasowała i walidowała każde pole i przechowywała w liście typu \texttt{TradeRecord}, dodatkowo wykonywała logowania do konsoli a następnie zapisywała te dane do bazy danych. 
% Jeśli nagle stwierdzimy, że nie chcemy korzystać ze strumienia a z WebAPI konieczna będzie zmiana tej klasy. Analogicznie jeśli zmieni się format danych, zasady walidacji, logowania czy będziemy korzystać z innej bazy danych. Zasada SRP została tutaj naruszona wielokrotnie. 
% Refaktoryzacja mogłaby polegać na utworzeniu trzech interfejsów: \texttt{ITradeDataProvider, ITradeParser oraz ITradeStorage} i korzystanie z nich przez klasę \texttt{TradeProcessor}. Klasy implemntujące te interfejsy będą odpowiedzialne za różne obszary odpowiedzialności. Obiekty można wstrzyknąć przez konstrutkor i dalej już klasa \texttt{TradeProcessor} może z nich korzystać przetwarzająć operacje (będzie pełniła role swego rodzaju fasady). Implementacje mogą znajdować się w tym samym zestawie, jednak jeśli korzystalibyśmy z zewnętrznych zależności (firm trzecich) należy wtedy je umieścić z osobnym zestawie. Np. jeśli chcemy korzystać z Dapper'a zamiast ADO.NET należy stworzyć zestawe Services.Dapper, który będzie implementował ITradeStorage nazwany DapperTradeStorage. Ważne, aby zależności nie były zaszyte w interfejsie, a jedynie wstrzykiwane przez konstruktor. Interfejs powinnien być czysty. Można dodać dodatkowe abstrakcje  np. \texttt{ParseTrades} wykonuje zarówno walidację jak i mapowanie. Tak więc podział można ponownie przeprowadzić i wyodrębnić dwa dodatkowe interfejsy \texttt{ITradeMapper} oraz \texttt{ITradeValidator}. Może tak postępować tak długo, aż każda klasa będzie posiadała tylko jedną odpowiedzielność. Jeśli omawiana klasa dodatkowo przeprowadzała logowanie to dobrze będzie stworzyć adapter na jedną z popularnych klas do logowania np. NLog.

\subsection{OCP - Zasada otwarte - zamknięte (ang. S\textbf{O}LID)}

Pisząc elastyczny kod powinniśmy być w stanie wprowadzać nowe funkcjonalności dodając nowe klasy jednocześnie \textbf{nie} modyfikując tych już istniejących. Nie zawsze jest to możliwe, ale zawsze warto próbować. 

\begin{myboxWithTitle}{Zasada otwarte - zamknięte}
Składniki oprogramowania (klasy, moduły, funkcje itp.) powinny być otwarte na rozbudowę, ale zamknięte dla modyfikacji.
\end{myboxWithTitle}

Aby osiągnąć ten cel oprogramowanie powinno posiadać jasno zdefiniowane, niezmienne abstrakcje. Jeśli dany moduł wykorzystuje jedynie abstrakcje, nie powinna być konieczna jego modyfikacja w przypadku zmian wymagań, rozszerzania funkcjonalności. Stosowanie zasady OCP wymaga wykorzystania polimorfizmu.
% Oczywiście te abstrakcje np. deklaracje intefejsów mogą się zmieniać jednak dzieje się to zdecydowanie rzadziej. Interfejsy powinny być zdecydowanie bardziej stabilne. 

Przeanalizujmy poniższy diagram UML. W tym przypadku zmiana obiektu \texttt{Order} wymagałaby zmian w~klasie klienta. 

\begin{figure}[hbt!]
	\centering
	\includegraphics[width=0.6\linewidth]{images/SolidOcpViolationUml}
	\caption{Diagram UML, gdzie \texttt{Client} narusza zasadę OCP.}
	\label{lab1/fig/SolidOcpViolationUml}
\end{figure}
%[Client]->[Order]
%[Client]
%[Order]

Stosując wzorzec projektowy strategia, który zostanie omówiony na kolejnych zajęciach mamy możliwość odwrócenia zależności. Jeśli w~wyniku rozszerzania, zmian funkcjonalności okaże się, że klasa \texttt{Order} powinna zostać zmieniona, będzie można utworzyć nową wersję klasy implementującej interfejs zdefiniowany przez klienta i ją podmienić bez modyfikacji w samej klasie \texttt{Client}.

%Zastosowano interfejs IClient zamiast IOrder, ponieważ związki klas abstrakcyjnych z klasami klienckimi są ściślejsze niż z konkretnymi potomnymi, które je implementują. 
\begin{figure}[hbt!]
	\centering
	\includegraphics[width=0.9\linewidth]{images/SolidOcpUml}
	\caption{Diagram UML, gdzie \texttt{Client} \textbf{nie} narusza zasady OCP.}
	\label{lab1/fig/SolidOcpUml}
\end{figure}
%[Client]->[IClient]^[Order]
%[Client]
%[IClient]
%[Order]

Wyobraźmy sobie moduł odpowiedzialny za rysowanie figur geometrycznych. Parametrem tej metody jest lista obiektów. Jeśli w wyniku zmian konieczne okaże się dodanie nowej klasy np. \texttt{Diamond} wymagane będą zmiany w klasie \texttt{Drawer}.
\begin{lstlisting}[caption={Naruszenie zasady OCP}, label={lab1/lst/ocpViolationShapes}]
public class Circle { }
public class Square { }

public static class Drawer 
{
	public static void DrawShapes(IEnumerable<object> shapes) 
	{
		foreach (object shape in shapes) 
		{
			if (shape is Circle) 
			{
				(shape as Circle).DrawCircle();
			} 
			else if (shape is Square) 
			{
				(shape as Square).DrawSquare();
			}
		}
	}
}
\end{lstlisting}

Stosując polimorfizm i abstrakcję możemy uniezależnić klasę \texttt{Drawer} od konkretnych typów. Dzięki utworzeniu wspólnego interfejsu i przekazywanie listy obiektów implementujących ten interfejs, dodanie nowej figury nie będzie wymagało zmian w kodzie klienta. Nie musimy dostosowywać już istniejące kodu do zmian.

\begin{lstlisting}[caption={Poprawne zastosowanie zasady OCP}, label={lab1/lst/ocpShapesCorrect}]
public interface IShape 
{ 
	void Draw(); 
}
public class Circle : IShape { public void Draw() { }}
public class Square : IShape { public void Draw() { } }

public static class Drawer 
{
	public static void DrawShapes(IEnumerable<IShape> shapes) 
	{
		foreach (IShape shape in shapes) 
		{
			shape.Draw();
		}
	}
}
\end{lstlisting}

%Niestety istnieją takie zmiany, na które powyżej pokazana implementacja nie jest odporna np. jeśli kolejność rysowania figur okazałaby się konieczna do uwzględnienia. To projektant musi przewidzieć jakie zmiany są najbardziej prawdopodobne i określić odpowiednie zabezpieczenia. Zamiast stosować punkty szczepień (miejsca w programie, w których przewidujemy, że być może kiedyś będą zmiany), może zastosować zasadę mówiącą, że "Gdy raz mnie oszukasz, powinieneś się wstydzić. Kiedy oszukasz mnie po raz drugi, to ja powinienem się wstydzić". Jednocześnie powinniśmy na bieżąco sprawdzać nasze oprogramowanie i zdobywać wiedzę o prawdopodobnych rodzajach zmian. 

%Problem z kolejnością rysowanych figur możnaby rozwiązać stosując dodatkową klasę ShapeComparer : IComparer, która to zawiera statyczną tablicę priorytetów, na której to podstawie określane są priorytety rysowania figur. Metoda DrawShapes może wtedy wywolać metodę shapes.Sort(new ShapeComparer) prze rysowaniem figur (str. 186).

Oczywiście zmiany będą również konieczne w module, który tworzy instancje obiektów typu \texttt{Shape}. Ale ten proces jest zazwyczaj hermetyzowany w metodzie \texttt{Main} albo w fabrykach.

\subsubsection{Zadanie 2}
Utwórz projekt w dodaj do niego klasę o~nazwie \texttt{UI} z metodą \texttt{Drawer} analogicznie jak zostało to pokazane powyżej\ref{lab1/lst/ocpShapesCorrect}. Utwórz w osobnych plikach klasy: \texttt{Circle}, \texttt{Square}, \texttt{Rectangle} oraz \texttt{Triangle}. Wszystkie powinny implementować interfejs \texttt{IShape} posiadający metodę \texttt{Draw()}. Zaimplementuj w klasach kształtów ten interfejs przez proste wypisywanie na ekranie konsoli informacji, że funkcja \texttt{Draw} została wywołana np.:
\begin{lstlisting}
public class Square : IShape
{
	public void Draw() => Console.WriteLine("Square has been drawn.");
}
\end{lstlisting}
W metodzie \texttt{Main} utwórz kilka instancji klas kształtów i dodaj je do listy albo innego kontenera i przekaż do metody \texttt{DrawShapes} klasy \texttt{Draw} (wcześniej utwórz obiekt tej klasy, aby móc z niego skorzystać).

\subsection{LSP - Zasada podstawienia Liskov (ang. SO\textbf{L}ID)}

Zasada podstawienia Liskov pozawala odpowiedzieć na pytanie jakie są dobre praktyki tworzenia hierarchii klas i co zrobić, aby były one zgodne z zasadą otwarte-zamknięte. Klient powinien móc bez zastanowienia się używać wymiennie klasy bazowej oraz klas pochodnych. W sytuacji braku możliwości podstawienia obiektów pochodnych w miejsce obiektów klasy bazowej występuje naruszenie zasady LSP. Często w konsekwencji zostaje również naruszona zasada OCP.

\begin{myboxWithTitle}{Zasada podstawienia Liskov}
Musi istnieć możliwość zastępowania typów bazowych ich podtypami.
\end{myboxWithTitle}

Lepsze zrozumienie zasady LSP można uzyskać analizując popularny przykład klasy prostokąta oraz klasy kwadratu, która jest pochodną klasy prostokąta. Zasadność stosowania dziedziczenia często jest analizowania przez zadanie sobie pytania czy klasy są w relacji \textbf{IS-A}. Niewątpliwie kwadrat jest prostokątem. Jednak pierwszy problem się pojawia w sytuacji, gdy chcemy zaimplementować/skorzystać z właściwości \texttt{Height} i~\texttt{Width} oraz dalej metody \texttt{Area}, zwracająca pole powierzchni danej figury. Są one całkowicie uzasadnione w~przypadku prostokąta, jednak wątpliwe w klasie kwadratu. 

Próbując rozwiązać ten problem można napisać klasę tak, że w momencie ustawiania właściwości wysokości albo szerokość w klasie kwadratu, będzie ustawiana zarówno wysokości jak i szerokość na taką samą wartość. Właściwości te mogą w klasie bazowej być wirtualne. 

Spójrzmy na poniższy kod, w sytuacji gdy do funkcji zostałby przekazany obiekt kwadratu.
\begin{lstlisting}[caption={Naruszenie zasady LSP}, label={lab1/lst/lspViolationSquareRectangle}]
void Foo(Rectangle r)
{
	r.Width = 5;
	r.Height = 4;
	if(r.Area() != 20) {throw new ...}
}
\end{lstlisting}

W powyższym przypadku okazuje się, że klient nie jest w stanie użyć instancji klasy pochodnej, w miejscu, gdzie oczekuje on klasy bazowej. Autor klasy pochodnej naruszył niezmienność klasy bazowej \texttt{Rectangle}.


Przewidzieć takie założenia, można za pomocą  programowanie przez kontrakt (tzw. DBC ang. Design By Contract). Polega ona na dodaniu do metod pewnych warunków wejściowych oraz wyjściowych, które muszą być spełnione, aby metoda mogła się wykonać. 

\begin{mybox}
Ponowna deklaracja procedury (w klasie potomnej) może zastępować warunki wstępne tylko warunkami równymi lub słabszymi, natomiast warunki wyjściowe może zastępować tylko warunkami równymi lub mocniejszymi.
\end{mybox}

Warunki wyjściowe właściwości \texttt{Rectangle.Width} mogłyby zostać zdefiniowane jako:
\begin{lstlisting}
	assert((width ==w ) && (height == old.height));
\end{lstlisting}

Innym problemem, może być sytuacja, gdy dana metoda klasy bazowej przyjmuje dowolny obiekt, natomiast w klasie pochodnej istnieje nieznany wymóg, że obiekt ten musi być konkretnego typu np. z powodu wykonywania operacji rzutowania. Klasa pochodna będzie zgłaszać niezrozumiały dla klienta wyjątek.

Reguły którymi należy się kierować, aby zachować zgodność z zasadą LSP mogą zostać podzielone na dwie kategorie: warunki kontraktu oraz warunki wariancji. Podczas laboratoriów skupimy się na tych pierwszych. Warunki wariancji natomiast są związane z zmiennością argumentów i typów zwracanych. 
%The concept of type variance in the languages of the Common Language Runtime (CLR) of the Microsoft .NET Framework is limited to generic types and delegates. However, variance in these scenarios is well worth exploring and will equip you with the requisite knowledge to write code that is LSP compliant for variance. This will be explored in depth in the “Covariance and contravariance”
%section later in this chapter


\subsubsection{Warunki kontraktu}
Warunki wstępne klasy bazowej nie mogą zostać zaostrzone w klasie pochodnej. Warunki końcowe nie mogą zostać złagodzone w klasie pochodnej. Inwarianty muszą pozostać takie same w klasie pochodnej jakie były w klasie bazowej.

% Często zamienie mówi się, że programiści powinni programować do interfejsów oraz programować do kontraktu. Interfejsy jednak słabo przekazują informację o kontrakcie. Sygantury bardzo niewiele mówią o wymaganiach i gwarancji wywoływanej metody. W językach silnie typowanych jedyne co mamy to informację o typie, ale w tym miejscu intefejsy się kończą i w ich miejsce wchodzą kontrakty. 
% Bardzo wazne jest, aby nazwy argumentow byly opisowe, metody powinny od razu informować co robią, a argumenty czym są. Można nawet w nazwach dodac jednostki miar, aby dodatkowo sprezycoważ argument. 

Sygnatura określona w interfejsie danej metody informuje o tym jakiego typu parametry metoda przyjmuje. Jednak w przypadku, gdy wymagane są dodatkowe ograniczenia np. waga przedmiotu nie może być liczbą ujemną, konieczne jest użycie kontraktu. Warunki początkowe powinny być definiowane tak, aby metoda mogła się wykonać poprawnie. Jednym ze sposobów, aby wymusić stosowanie kontraktu jest rzucenie wyjątkiem, w przypadku złej wartości argumentu wejściowego. Jeśli kontrakt nie zostanie spełniony, klient będzie zmuszony przechwycić i obsłużyć wyjątek, w przeciwnym razie wykonywanie programu się zakończy.

Warto w tym miejscu powiedzieć, że w przypadku kontraktów należy używać wyjątków, a nie asercji. Asercje służą, do znajdowania naszych błędów, natomiast wyjątki, aby poradzić sobie z błędami popełnionymi przez użytkowników czy innych programistów wykorzystujących nasz kod. Inaczej mówiąc, w przypadku sprawdzania warunków w publicznym API należy stosować wyjątki. Jeśli sprawdzamy własne, wewnętrzne warunki można używać asercji.

Asercji można używać bardzo liberalnie. Informują one o tym czego kod oczekuje w danym momencie. Wyjątki dotyczą bardziej tego czego żądamy. Dobrze napisane asercje mogą nam powiedzieć nie tylko co się stało oraz gdzie, ale również dlaczego. Służą za dodatkową dokumentację. Jeśli podczas działania programu wystąpi błąd związany z asercją możemy dołączyć debugger do procesu i sprawdzić stan stosu. 
% Asercje z kodu produkcyjnego zostają wycięte może się wydawać, że stosowanie ich nie ma sensu. Jednak jeśli poźniej będzie konieczność odtworzenia problemu przez dewelopera to łatwo będzie możliwość znalezienia źródła problemu.

\subsubsection{Zadanie 3}
\begin{enumerate}
	\item Stwórz nowy projekt .NET 5.0.
	\item Utwórz klasę o nazwie \texttt{ShippingStrategy} i dodaj do niej metodę \texttt{CalculateShippingCost}, która będzie przyjmowała argumenty: \texttt{float packageWeigthInKilograms}, \texttt{Size packageDeimensionInInches}, \texttt{string destination}.
	\item Wewnątrz klasy utwórz zmienną pomocniczą typu \texttt{decimal} i przypisz do niej dowolną wartość (nie ma ona w tym momencie znaczenia). Będzie ona przechowywała zwracaną wartość, nadaj jej stosowną opisową nazwę.
	\item Dodaj do metody kontrakt w postaci rzucanego wyjątku typu \texttt{ArgumentOutOfRangeException} w przypadku, gdy przekazywane parametry są niewłaściwe np. są liczbami ujemnymi.
	\item Na końcu metody zwróć utworzoną wcześniej pomocniczą zmienną.
\end{enumerate}

Analogicznie warunki końcowe powinny być sprawdzane na końcu metody, aby zagwarantować że metoda nie zmieniła stanu obiektu albo, że zwracana wartość jest poprawna. 

\begin{enumerate}
	\item Dodaj warunek końcowy, który będzie sprawdzał, czy obliczone koszty wysyłki są dodatnie. W przeciwnym razie zgłoś wyjątek.
	\item W metodzie \texttt{Main} utwórz obiekt klasy \texttt{ShippingStrategy} i wywołaj funkcję z poprawnymi i błędnymi argumentami, sprawdź czy został wygenerowany wyjątek.
\end{enumerate}

Dodatkowo jeśli klient ma możliwość zmiany pewnej właściwości, która musi przyjmować ściśle określone wartości, powinna również zostać zabezpieczona w analogiczny sposób.

\begin{enumerate}
	\item W utworzonej przed chwilą klasie dodaj prywatną \textbf{zmienna} typu \texttt{decimal} o nazwie \texttt{flatRate}.
	\item Dodaj właściwość \texttt{FlatRate} z metodą dostępu \texttt{get} oraz akcesorem \texttt{set}.
	\item Wewnątrz akcesora \texttt{set} dodaj sprawdzenie ustawianej wartości tak jak dla warunków początkowych i końcowych.
	\item Sprawdź działanie kontraktu z poziomu metody \texttt{Main}.
\end{enumerate}

Zamiast kod kontraktów umieszczać wewnątrz metody, lepiej byłoby utworzyć osobne klasy typu \texttt{Weight} czy \texttt{Deimension} i~to w~nich dodać powyższe kontrakty. W~ten sposób w~całym kodzie kontrakty dla danych typów będą spójne oraz zmniejszy liczba duplikowanego kodu. 

\subsubsection{Zadanie 4}
Zbadaj kontrakty w kontekście zasady LSP:
\begin{enumerate}
	\item Oznacz metodę \texttt{CalculateShippingCost} jako wirtualną.
	\item Utwórz klasę pochodną względem \texttt{ShippingStrategy} i nazwij ją np. \texttt{WorldWideShippingStrategy}.
	\item Za pomocą słowa kluczowego \texttt{override} przesłoń wirtualną metodę klasy bazowej i dodaj w niej sprawdzenie czy wartość argumentu \texttt{destination} nie jest \texttt{null}.
	\item Utwórz teraz w metodzie \texttt{Main()} dwa obiekty w sposób pokazany poniżej\ref{lab1/lst/lspShippingStrategiesCall}. 
\end{enumerate}

Zwróć uwagę, że w drugim przypadku został zgłoszony wyjątek. Klient musi w takiej sytuacji rozróżniać różne typu wykorzystywanych obiektów co łamie zasadę LSP oraz wprowadza dodatkowe zależności 

\begin{lstlisting}[caption={Wywołanie metod klas ShippingStrategy oraz WolrdWideShippingStrategy}, label={lab1/lst/lspShippingStrategiesCall}]
class Program
{
	static void Main(string[] args)
	{
		ShippingStrategy shippingStrategyA = new ShippingStrategy();
		ShippingStrategy shippingStrategyB = new WorldWideShippingStrategy();
		
		shippingStrategyA.CalculateShippingCost(10, new ShippingStrategy.Size(10,10), null);
		shippingStrategyB.CalculateShippingCost(10, new ShippingStrategy.Size(10, 10), null);
	}
}
\end{lstlisting}

Analogicznie złamany może być warunek końcowy. Załóżmy, że w klasie bazowej w przypadku wysyłki do tego samego kraju koszt dostawy jest zerowy. Natomiast w klasie pochodnej jest on zawsze większy od zera. Powoduje to złamanie zasady, że warunki końcowe nie powinny być rozluźniane w klasie pochodnej. Dokładnie ta sama zasada dotyczy danych niezmiennych (invariant data), w naszym przykładzie właściwości \texttt{FlatRate}. Klasa pochodna nie powinna w żaden sposób zmieniać nałożonych wcześniej ograniczeń.

Aby uprościć tworzenie kontraktów można napisać prostą metodę statyczną, która ułatwi ten proces:
\begin{lstlisting}
public class CustomContract
{
	public static void Requires<TException>( bool Predicate, string Message )
	where TException : Exception, new()
	{
		if ( !Predicate )
		{
			Debug.WriteLine( Message );
			throw new TException();
		}
	}
}  	
\end{lstlisting}
\texttt{Requires} jest metodą generyczną, gdzie \texttt{T} musi być typu referencyjnego oraz posiadać bezparametrowy konstruktor.

% Sytuacja może być niebezpieczne np. jeśli klient przez poczynione założenie, że wartość jest dodania wykona operację dzielenia przez zero.

%\subsubsection{Wykorzystanie kontraktów z \texttt{System.Diagnostics.Contracts}}

%Kontrakty z \texttt{System.Diagnostics.Contracts} nie są już wspierane.

%Jak można było zauważyć pisanie kontraktów w sposób pokazany powyżej może być żmudne. Dodatkowo sprawdzenie naruszenia kontraktu miało miejsce podczas wykonywania się programu. Wykorzystując kontrakty znajdujące się w przestrzeni nazw \texttt{System.Diagnostics.Contracts} można uprościć sobie proces tworzenia kontraktów.
%
%\begin{enumerate}
%	\item Utwórz nowy plik z klasą \texttt{ShippingStrategyCodeContracts}.
%	\item Dodaj na górze pliku przestrzeń nazw za pomocą \texttt{using System.Diagnostics.Contracts}.
%	\item Zamiast wykorzystywać klauzulę \texttt{if} utwórz kontrakt tak jak pokazano poniżej\ref{lab1/lst/lspCodeContractsPreCondition}. Zwróć uwagę, na odwróconą logikę wewnątrz metody \texttt{Requires} względem wcześniejszego przykładu. Dodatkowo istnieje możliwość zdefiniowana zgłaszanego wyjątku.
%	\item Analogicznie można utworzyć kontrakty dla warunków końcowych\ref{lab1/lst/lspCodeContractsPostCondition} oraz danych inwariantnych\ref{lab1/lst/lspCodeContractsDataInvariant}.
%\end{enumerate}

%\begin{lstlisting}[caption={Tworzenie kontraktów z wykorzystaniem \texttt{System.Diagnostics.Contracts} - warunki początkowe}, label={lab1/lst/lspCodeContractsPreCondition}]
%public class ShippingStrategyCodeContracts
%{
%	public virtual decimal CalculateShippingCost(float packageWeightInKilograms, float packageDimensionInInches, string destination)
%	{
%		//Preconditions
%		Contract.Requires(packageWeightInKilograms > 0);
%		Contract.Requires<ArgumentOutOfRangeException>(packageDimensionInInches > 0);
%		
%		//...
%	}
%}
%\end{lstlisting}

%\begin{lstlisting}[caption={Tworzenie kontraktów z wykorzystaniem \texttt{System.Diagnostics.Contracts} - warunki końcowe}, label={lab1/lst/lspCodeContractsPostCondition}]
%public class ShippingStrategyCodeContracts
%{
%	public virtual decimal CalculateShippingCost(float packageWeightInKilograms, float packageDimensionInInches, string destination)
%	{
%		//...
%		
%		//Postconditions
%		Contract.Ensures(Contract.Result<decimal>() > 0);
%		
%		return decimal.MinValue;
%	}
%}
%\end{lstlisting}

%\begin{lstlisting}[caption={Tworzenie kontraktów z wykorzystaniem \texttt{System.Diagnostics.Contracts} - dane inwariantne}, label={lab1/lst/lspCodeContractsDataInvariant}]
%public class ShippingStrategyCodeContracts
%{
%	[ContractInvariantMethod]
%	private void ClassInvariant()
%	{
%		Contract.Invariant(this.FlatRate > 0m, "Flat rate must be positive and non-zero");
%	}   
%	
%	public decimal FlatRate { get; set; }
%}
%\end{lstlisting}
\subsection{ISP - Zasada segregacji interfejsów (ang. SOL\textbf{I}D)}

Interfejsy klas nie powinny być rozbudowane. Jeżeli jedna klasa korzysta jedynie w pewnych funkcjonalności jakie zakłada interfejs, a druga z innych to taki interfejs powinien zostać podzielony na dwa niezależne od siebie. Do celów zapewnienia zgodności z zasadą separacji interfejsów można skorzystać z techniki dziedziczenia wielokrotnego. Należy pamiętać, że w C\# klasa nie może dziedziczyć po więcej niż jeden klasie, natomiast może implementować wiele interfejsów. Obiekty klienckie mogą korzystać z tego samego obiektu za pośrednictwem różnych interfejsów. Powinny one zależeć wyłącznie od wywoływanych przez siebie metod.  

\begin{myboxWithTitle}{Zasada segregacji interfejsów}
Klient nie powinien być zmuszany do zależności od metod, których nie używa.
\end{myboxWithTitle}


Wyobraźmy sobie, że musimy przygotować program obsługujący interfejs użytkownika bankomatu. Konieczne jest zapewnienie możliwości obsługi urządzenia w wykorzystaniem interfejsu graficznego, syntezatora mowy oraz za pomocą języka Braille'a (klasy interfejsy użytkownika). 

Zakładamy, że każda operacja dowolnej transakcji jest realizowana przez osobną klasę na przykład mogą to być typy: \texttt{DepositTransaction}, \texttt{WithdrowalTransaction} oraz \texttt{TransferTransaction}, wszystkie mogą dziedziczyć po abstrakcyjnej klasie bazowej z pojedynczą metodą \texttt{Execute}. Jednocześnie wszystkie muszą korzystać z klas, które realizują funkcję UI (klasy te powinny implementować interfejs \texttt{IUI}). Klasa realizująca obsługę z wykorzystaniem syntezatora mowy, musi implementować wszystkie możliwe operacje przewidziane przez klasy pochodne względem \texttt{Transaction}, co jest sensowne. Problemem jest jednak fakt, że np. klasa \texttt{DepositTransaction} musi niepotrzebnie znać/posiadać referencje do całego obiektu implementującego UI. Wystarczyłaby by funkcja \texttt{RequestDepositAmount}, obiekt nie jest zainteresowany np. \texttt{RequestTransferAmount}. 

Rozwiązanie tego problemu zostało pokazano na diagramie UML~\ref{lab1/fig/SolidIspUml}. Dzieląc gruby interfejs \texttt{IUI} można odciążyć klientów od posiadania referencji od obiektów, których funkcjonalności nie potrzebują. Co więcej, jeśli zostanie dodana nowa transakcja np. \texttt{PayGasBillTransaction} nie będzie konieczności ponownej przebudowy pozostałych klas transakcji w wyniku zmiany grubego interfejsu UI. 

\begin{figure}[hbt!]
	\centering
	\includegraphics[width=0.8\linewidth]{images/SolidIspUml}
	\caption{Diagram UML projektu w którym zrealizowano zasadę segregacji interfejsów.}
	\label{lab1/fig/SolidIspUml}
\end{figure}
%[Transaction]^[Deposit Transaction]
%[Transaction]^[Withdrawal Transaction]
%[Transaction]^[Transfer Transaction]
%
%[Deposit Transaction]->[DepositUI]
%[Withdrawal Transaction]->[WithdrawalUI]
%[Transfer Transaction]->[TransferUI]
%
%[DepositUI]^-.-[UI]
%[WithdrawalUI]^-.-[UI]
%[TransferUI]^-.-[UI]
%
%[<<Abstract>>Transaction|+Execute()]
%
%[Deposit Transaction]
%[Withdrawal Transaction]
%[Transfer Transaction]
%
%[≪interface≫;DepositUI|+RequestDepositAmount]
%[≪interface≫;WithdrawalUI|+RequestWithdrawalAmount;+InformInsufficientFunds]
%[≪interface≫;TransferUI|+RequestTransferAmount]
%
%[≪interface≫;UI|+RequestDepositAmount;+RequestWithdrawalAmount;+InformInsufficientFunds;+RequestTransferAmount]

W sytuacji, gdy pewna klasa kliencka albo metoda, potrzebowałaby wykorzystać obiekt implementujący zarówno \texttt{IDepositUI} oraz \texttt{IWithdrowalUI}, można jako argumenty konstruktora i metody przekazać dwa razy ten sam obiekt w następujący sposób: \texttt{Foo(ui,ui)}. Deklaracja konstruktora miałaby postać: \texttt{void Foo(IDepositUI depositUI, IWithdrowalUI withdrowalUi)}.

Ciekawym przykładem zastosowania zasady ISP jest wykorzystanie interfejsów do umożliwienia wykonywania operacji jedynie po wcześniejszym uwierzytelnieniu użytkownika. Przed operacją logowania klient korzysta z interfejsu \texttt{IUnauthorized}:
\begin{lstlisting}
public interface IUnauthorized
{
	IAuthorized Login(string username, string password);
	void RequestPasswordReminder(string emailAddress);
}
\end{lstlisting}
natomiast po zalogowaniu, poprawnym uwierzytelnieniu, zwracany jest obiekt implementujący \texttt{IAuthorized}:
\begin{lstlisting}
public interface IAuthorized
{
	void ChangePassword(string oldPassword, string newPassword);
	void AddToBasket(Guid itemID);
	void Checkout();
	void Logout();
}
\end{lstlisting}
Drugi z wymienionych interfejsów umożliwia wykonanie większej liczby operacji. Rozwiązanie to zabezpiecza programistę przez udostępnieniem uprzywilejowanych operacji przez niezalogowanego użytkownika. Jest to lepsze rozwiązanie niż umieszczać w interfejsie wszystkie operacje jakie może użytkownik wykonać. 

\subsubsection{Zadanie 5}
Poniższy interfejs\ref{lab1/lst/ispCrudInterface} zawiera zbiór zapytań i poleceń do pamięci trwałej. Poniżej natomiast została pokazana przykładowa implementacja\ref{lab1/lst/ispCrudInterfaceImplementation} tego interfejsu korzystająca z bazy danych MongoDB\footnote{Baza danych typu NoSQL w której dane przechowywane są jako pliki z formacie JSON.} do zapytań oraz NHibernate\footnote{Biblioteka ORM przeznaczone na platformę .NET do mapowania obiektów modelu domeny na relacyjną bazę danych.} do poleceń.
\begin{lstlisting}[caption={Interfejs zawierający zbiór operacji CRUD}, label={lab1/lst/ispCrudInterface}]
public interface IPersistence
{
	IEnumerable<Entity> GetAll();
	Item GetByID(Guid identity);
	IEnumerable<Entity> FindByCriteria(string criteria);
	void Save(Entity entity);
	void Delete(Entity entity);
}
\end{lstlisting}

\begin{lstlisting}[caption={Implementacja interfejsu \texttt{IPersistence}}, label={lab1/lst/ispCrudInterfaceImplementation}]
public class Persistence : IPersistence
{
	private readonly ISession session;
	private readonly MongoDatabase mongo;
	public Persistence(ISession session, MongoDatabase mongo)
	{
		this.session = session;
		this.mongo = mongo;
	}
	public IEnumerable<Entity> GetAll()
	{
		return mongo.GetCollection<Entity>("entities").FindAll();
	}
	public Entity GetByID(Guid identity)
	{
		return mongo.GetCollection<Entity>
		("entities").FindOneById(identity.ToBson());
	}
	public IEnumerable<Entity> FindByCriteria(string criteria)
	{
		var query = BsonSerializer.Deserialize<QueryDocument>
		(criteria);
		return mongo.GetCollection<Entity>("entities").Find(query);
	}
	public void Save(Entity entity)
	{
		using(var transaction = session.BeginTransaction())
		{
			session.Save(entity);
			transaction.Commit();
		}
	}
	public void Delete(Entity entity)
	{
		using(var transaction = session.BeginTransaction())
		{
			session.Delete(entity);
			transaction.Commit();
		}
	}
}
\end{lstlisting}
Często można natomiast się spotkać z rozdzieleniem operacji odczytu i aktualizacji bazy danych. Przykładem tej koncepcji jest m.in wzorzec CQRS, o którym szerzej będziemy mówić przy okazji czynnościowych wzorców projektowych. Na ten moment najprościej ujmując polega on na rozdzieleniu operacji odczytu od operacji aktualizacji. 

Zastanów się jak można podzielić interfejs\ref{lab1/lst/ispCrudInterface} na dwa mniejsze jeden dla poleceń drugi dla zapytań. Dwie klasy np. \texttt{CommandsNHibernate} oraz \texttt{QueriesMongo} mogłyby implementować odpowiednio \texttt{ICommands} i~\texttt{IQueries}. Klasa kontrolera w takiej sytuacji mogłaby posiadać referencję do dwóch obiektów implementujących wspomniane interfejsy. Takie podejście pozwala na niezależne korzystanie z dwóch rodzajów baz danych, ich swobodną wymianę i skalowanie. Implementacje mogłyby znajdować się różnych w pakietach co jest dodatkową korzyścią 

%\begin{lstlisting}
%public interface IPersistenceQueries
%{
%	IEnumerable<Item> GetAll();
%	Item GetByID(Guid identity);
%	IEnumerable<Item> FindByCriteria(string criteria);
%}
%// . . .
%public interface IPersistenceCommands
%{
%	void Save(Item item);
%	void Delete(Item item);
%}
%\end{lstlisting}
%
%\begin{lstlisting}
%public class PersistenceQueries : IPersistenceQueries
%{
%	private readonly MongoDatabase mongo;
%	public Persistence(MongoDatabase mongo)
%	{
%		this.mongo = mongo;
%	}
%	public IEnumerable<Item> GetAll()
%	{
%		return mongo.GetCollection<Item>("items").FindAll();
%	}
%	public Item GetByID(Guid identity)
%	{
%		return mongo.GetCollection<Item>
%		("items").FindOneById(identity.ToBson());
%	}
%	public IEnumerable<Item> FindByCriteria(string criteria)
%	{
%		var query = BsonSerializer.Deserialize<QueryDocument>
%		(criteria);
%		return mongo.GetCollection<Item>("Items").Find(query);
%	}
%}
%\end{lstlisting}
%
%\begin{lstlisting}
%public class PersistenceCommands : IPersistenceCommands
%{
%	private readonly ISession session;
%	public PersistenceCommands(ISession session)
%	{
%		this.session = session;
%	}
%	public void Save(Item item)
%	{
%		using(var transaction = session.BeginTransaction())
%		{
%			session.Save(item);
%			transaction.Commit();
%		}
%	}
%	public void Delete(Item item)
%	{
%		using(var transaction = session.BeginTransaction())
%		{
%			session.Delete(item);
%			transaction.Commit();
%		}
%	}
%}
%\end{lstlisting}


\subsection{DIP - Zasada odwracania zależności (ang. SOLI\textbf{D})}

Głównie za sposób działania aplikacji odpowiadają moduły wysokopoziomowe. To one zawierają logikę biznesową, która często jest wielokrotnie wykorzystywana. Przemyślana architektura obiektowa powinna składać się z wyraźnie zdefiniowanych i odznaczających się warstw. Usługi powinny być opisane odpowiednimi, niezmiennymi interfejsami\footnote{Rzadko udaje się osiągnąć sytuację, w której interfejsy są niezmienne w szczególności na początkowym etapie projektu. Jednak powinny one być zdecydowanie bardziej stabilne niż klasy.}.

\begin{myboxWithTitle}{Zasada odwracania zależności}
	A. Moduły wysokopoziomowe nie powinny zależeć od modułów niskopoziomowych. Obie grupy modułów powinny zależeć od abstrakcji.\\
	B. Abstrakcje nie powinny zależeć od szczegółowych rozwiązań. To szczegółowe rozwiązania powinny zależeć od abstrakcji.
\end{myboxWithTitle}

Nie należy postrzegać bibliotek jako właścicieli interfejsów. Interfejsy powinny być powiązane ze swoimi właścicielami i to klasy z innej warstwy powinny implementować te interfejsy. Pozwala to tworzyć oprogramowanie, które jest elastyczne. Jeśli dany zestaw jest wykorzystywany przez kilku klientów np. pobrany pakiet NuGet to warto stworzyć dodatkową warstwę abstrakcji, która umożliwi w przyszłości zmianę tego pakietu, bez konieczności wprowadzania zmian po stronie klienta. Można to osiągnąć np. stosując wzorzec projektowy Adapter, który zostanie omówiony na przyszłych zajęciach. Oczywiście jeśli mamy do czynienia z klasami, które są zmieniane bardzo rzadko, albo mamy wysoki poziom zaufania to autorów to uzależnienie się od nich nie jest czymś złym. Ciężko znaleźć sens, tworzenia dodatkowej warstwy pośredniej do komunikowania się np. z~klasą \texttt{string}.

Wyobraźmy sobie przykład dwóch klas \texttt{Button} oraz \texttt{Lamp}. Klasa przycisku ma możliwość sterowania lampą. W~najprostszej, naiwnej implementacji można by dodać pole w klasie \texttt{Button} przechowujące referencje do obiektu lampy. \texttt{Lamp} mógłby być przekazywany np. jako argument konstruktora. Dlaczego te podejście jest złe i łamie zasadę DIP? \texttt{Button} będący wysokopoziomową abstrakcją, jest uzależniony od niskopoziomowego obiektu lampy.

Powyższy problem można by rozwiązać przez dodanie interfejsu np. \texttt{ISwitchableDevice} i wstrzykiwanie obiektu go implementującego do obiektu \texttt{Button}. Teraz wystarczy, aby \texttt{Lamp} implementował ten interfejs. W~przypadku, kiedy przycisk będzie miał zostać wykorzystany do sterowania np. silnikiem albo piecem wystarczy utworzyć nowy obiekt \texttt{Motor} albo \texttt{Heater}, który będzie implementował \texttt{ISwitchableDevice} i przekazać go do obiektu \texttt{Button}.

% Można narysować kilka warstw: Controllers, Services, Domain oraz NHibernate. Warstwy zależą od siebie w kolejności takiej jak zostały wymienione. Dodatkowo interfejsy przynależą do konkretnej warstwy np. w warstwie Services znajduje się SecurityService oraz ISecurityService. W tym przypadku jeśli skompilujemy np. Conrollers, dalej w katalogu /bin będzie najdował się NHibernate i inne warstwy.

Odpowiednim podejściem jest umieszczenie interfejsów oraz ich implementacji w osobnych zestawach. Klienci powinny posiadać referencje jedynie do zestawu z interfejsem. W idealnym scenariuszu interfejsy nie powinny posiadać żadnych zależności, kod kliencki również, to implementacje powinny zależeć od interfejsów. 
\subsubsection{Zadanie 6}
Przeanalizuj poniższy kod i zmień go tak, aby był zgodny z omawianą zasadą DIP.
\begin{lstlisting}
const byte THERMOMETER = 0X86;
const byte FURNACE = 0X87;
const byte ENGAGE = 1;
const byte DISENGAGE = 0;

void Regulate(double minTemp, double maxTemp)
{
	for(;;)
	{
		while (in(THERMOMETER) > minTemp){ wait(1); }
		out(FURNACE, ENGAGE);
		while (in(THERMOMETER) < maxTemp){ wait(1); }
		out(FURNACE, DISENGAGE);	
	}
}
\end{lstlisting}

Możesz utworzyć dwa dodatkowe interfejsy, jeden dla obiektów mierzących temperaturę i drugi dla obiektów odpowiedzialnych za zmianę temperatury np. pieców. Dalej utwórz dwie konkretne klasy np \texttt{Thermometer} oraz \texttt{Heater} i uzależnij obiekt regulacji od tych abstrakcji. 

\subsection{Kontenery IoC (ang. Inversion of Control)}
Wstrzykiwanie zależności (DI ang. Dependency Injection) jest procesem, w którym wykorzystywany przez klasę obiekt jest przekazywany do niej np. jako argument konstruktora, a nie tworzony w~jego wnętrzu. Kontenery DI takie jak Castle Windsor, Autofac czy Ninject ułatwiają zarządzanie zależnościami. Jeśli pracujemy nad dużym projektem, w którym klasy zależą od wielu innych i wykorzystują mechanizm wstrzykiwania zależności można wykorzystać kontener DI, aby ułatwić sobie proces tworzenia obiektów. 

Na przykład tworzenie obiektu \texttt{CustomerService} pokazane poniżej\ref{lab1/lst/dpiComplexObjectConstruction} wymaga utworzeniu wielu innych obiektów i przekazania ich jako argumenty konstruktora.
\begin{lstlisting}[caption={Tworzenie obiektu posiadającego zależności wstrzykiwane przez konstruktor }, label={lab1/lst/dpiComplexObjectConstruction}]
public CustomerData GetCustomerData(string customerNumber)
{
	var customerApiEndpoint = ConfigurationManager.AppSettings["customerApi:customerApiEndpoint"];
	var logFilePath = ConfigurationManager.AppSettings["logwriter:logFilePath"];
	var authConnectionString = ConfigurationManager.ConnectionStrings["authorization"].ConnectionString;
	using(var logWriter = new LogWriter(logFilePath ))
	{
		using(var customerApiClient = new CustomerApiClient(customerApiEndpoint))
		{
			var customerService = new CustomerService(
			new SqlAuthorizationRepository(authorizationConnectionString, logWriter),
			new CustomerDataRepository(customerApiClient, logWriter),
			logWriter
			);   
			
			return customerService.GetCustomerData(string customerNumber);
		}
	}
}
\end{lstlisting}

Wykorzystując kontener DI można zarejestrować zależności, które będą tworzone i wstrzykiwane automatycznie. Jeśli dana klasa potrzebuje np. obiektu implementującego \texttt{ILogWriter}, kontener utworzy odpowiednią instancję jeśli została ona wcześniej zarejestrowana. Jeżeli np. tym obiektem jest \texttt{LogWriter} i wymaga on ścieżki do pliku, można również taką ścieżkę zarejestrować jako wartość klucza w \texttt{AppSettings}. Kontener ,,wie'' jakie obiekty, jakich typów muszą być utworzone i wstrzyknięte, aby spełnić wymagania tworzonej klasy. Jeśli odpowiedni obiekt nie został wcześniej zarejestrowany to zostanie zgłoszony wyjątek o tym informujący. Dodatkowo kontenery umożliwiają sprecyzowanie czy jedna i ta sama instancja ma zostać przekazana do wszystkich obiektów jej wymagających czy np. za każdym razem powinien być tworzony nowy obiekt.

Kontenery IoC powinny być wykorzystywane jedynie do wiązania poszczególnych elementów programu. Jeśli chcemy tworzyć obiekty podczas działania programu należy wykorzystywać fabryki. Trzeba unikać sytuacji w których w całym programie znajdują się referencje do kontenera. Zazwyczaj wystarcza jedno pobranie obiektu np. typu \texttt{Application}, natomiast reszta powiązań powinna odbywać się po stronie kontenera IoC.

\subsubsection{Zadanie 7}\label{lab1/ex/IoC}
Utwórz dwa projekty w solucji. Jeden niech będzie biblioteką, drugi natomiast aplikacją konsolową. Dodaj referencję do biblioteki w aplikacji konsolowej. Aby to zrobić kliknij PPM na projekt aplikacji konsolowej, dalej \texttt{Add} i \texttt{Project Reference...}, następnie wskaż odpowiedni zestaw. W~projekcie biblioteki utwórz następującą hierarchię klas:
\begin{figure}[hbt!]
	\centering
	\includegraphics[width=0.8\linewidth]{images/ExerciseIocLib}
	\caption{Diagram UML hierarchii klas biblioteki z zadania~\ref{lab1/ex/IoC}}
	\label{lab1/fig/IoC}
\end{figure}

%[BuisinessLogic]->[ILogger]
%[BuisinessLogic]->[IDataProvider]
%[ILogger]^-.-[Logger]
%[IDataProvider]^-.-[DataProvider]
%
%[≪IBuisinessLogic≫;BuisinessLogic|+ProcessData]
%[ILogger|+ProcessData]
%[Logger|+ProcessData]
%[IDataProvider|+GetData;+SetData]
%[DataProvider|+GetData;+SetData]

Zaimplementuj metody tak, aby wypisywały informację na konsoli o tym jaka metoda jest aktualnie wykonywana np.:
\begin{lstlisting}
public class Logger : ILogger
{
	public void Log(string msg) => Console.WriteLine($"{DateTime.Now}|{msg}");
}
\end{lstlisting}

Dodaj za pomocą menadżera pakietów NuGet pakiet \texttt{Autofac} do projektu aplikacji konsolowej.
Następnie utwórz w osobnym pliku klasę w której będzie następowała konfiguracja kontenera:
\begin{lstlisting}
public static class ContainerConfig
{
	public static IContainer Configure()
	{
		var builder = new ContainerBuilder();
		
		//...
		
		return builder.Build();
	}
}
\end{lstlisting}
Aby móc ,,pobrać'' instancję danej klasy z kontenera w pierwszej kolejności należy skojarzyć dane klasy z~odpowiadającymi im interfejsami. Inaczej mówiąc konieczne jest przekazanie informacji jaką klasę chcemy wykorzystać w miejsce danego kontenera. Należy to zrobić w następujący sposób:
\begin{lstlisting}
builder.RegisterType<BusinessLogic>().As<IBusinessLogic>();
//...
\end{lstlisting}
Powyższy fragment kodu oraz pozostałe rejestracje umieść w metodzie \texttt{Configure}.

Do projektu aplikacji konsolowej dodaj również interfejs \texttt{IApplication}, z jedną metodą \texttt{Run()} nie zwracającą żadnego obiektu. W pliku \texttt{Application} umieść implementację interfejsu \texttt{IApplication}:
\begin{lstlisting}
public class Application : IApplication
{
	private readonly IBusinessLogic businessLogic;	
	public Application(IBusinessLogic businessLogic) => this.businessLogic = businessLogic;	
	public void Run() => businessLogic.ProcessData();
}
\end{lstlisting}

W metodzie \texttt{Main} umieść poniższy kod:
\begin{lstlisting}
static void Main(string[] args)
{
	//First thing we want to in program do is wireup the container and dependencies
	var container = ContainerConfig.Configure();
	
	using(var scope = container.BeginLifetimeScope()) //new scope 
	{
		var app = scope.Resolve<IApplication>(); //we need IApplication object, hence container gives us one
		app.Run();
	}
	
	Console.ReadLine();
}
\end{lstlisting}
Uruchom program i sprawdź, czy kontener poprawnie powiązał i stworzył wszystkie obiekty.

W momencie wywołania \texttt{Resolve} kontener sprawdza jakiego typu obiekty należy przekazać do konstruktora obiektu i wstrzykuje je za nas. W naszym przypadku po wywołaniu metody \texttt{Resolve<IApplication>} kontener ,,widzi'', że wymagany jest obiekt implementujący \texttt{IBusinessLogic}, aby utworzyć \texttt{Application}. Dalej \texttt{BusinessLogic} wymaga przekazania obiektu implementującego \texttt{ILogger} oraz \texttt{IDataProvider}. I~w~tym przypadku zostaną za nas utworzone odpowiednie obiekty i przekazane do \texttt{BusinessLogic} tak, aby mógł on zostać stworzony na potrzeby \texttt{Application}.

Aby ułatwić proces wiązania danych obiektów, można zamiast rejestrować poszczególne typy, zarejestrować cały zestaw wraz z określeniem pewnym warunków. Np. można zarejestrować wszystkie obiekty z~zestawu, których nazwy zaczynają się danym prefiksem, albo znajdują się w danym folderze. Można również powiązać wszystkie klasy z zestawu z odpowiadającymi im interfejsami.
\begin{lstlisting}
builder.RegisterAssemblyTypes(Assembly.Load(nameof(DependencyInversionPrincipleLib)))
//.Where(t => t.Namespace.Contains("Loggers")) //only from specific folder
.AsImplementedInterfaces(); //register the type as providing all of its public interfaces as services (excluding IDisposable).

\end{lstlisting}