\section{Refaktoryzacja}

Refaktoryzacja jest procesem zmiany \textbf{działającego} kodu, bez wpływania na jego zachowanie (kod przed i po refaktoryzacji powinien działać tak samo). Poprawie ulegają jego wewnętrzne struktury. Podczas procesu refaktoryzacji kod powinien być cały czas sprawny. 

Refaktoryzacja powinna być naturalną koleją rzeczy podczas rozwijania oprogramowania. Pozwala na zwiększenie czytelności kodu, jest to szczególnie ważne dla kolegów z zespołu jak i nas samych w przyszłości. Refaktoryzacja polepsza projekt, ułatwia jego modyfikowanie i rozszerzanie. Dodatkowo sprawia, że znalezienie błędów staje się prostsze, a samo programowanie szybsze i sprawniejsze.
% Często jak się zaczyna dany projekt to prace nad nim idą jak burza, dopiero to pewnym czasie następuje stagnacja. Refaktoryzacja pozwala uniknąć tej stagnacji, jeśli projekt jest dobrze rozwijany dodawanie nowych funkcjonalności nie powinno być dużym problemem.  

\subsection{,,Zapachy'' w kodzie}
W kontekście refaktoryzacji często pojawia się słowo ,,zapach'' kodu. ,,Zapaszki'' sugerują miejsca, gdzie w naszym kodzie może dziać się coś złego. Wskazują fragmenty, które potencjalnie powinny zostać podane refaktoryzacji. W~książce Martin Fowler wyróżnia następujące ,,zapachy'':
\begin{itemize}
	\item Tajemnicza nazwa - nazwy metod, klas, pól powinny jasno określać za co dana składowa jest odpowiedzialna. Dzięki narzędziom refaktoryzacyjnym dostępnym w środowiskach IDE, zmiana nazw jest bardzo prosta i warto z niej często korzystać.
	\item Zduplikowany kod - jeśli fragment kodu pojawia się w dwóch miejscach jego utrzymanie staje się trudne. Konieczne jest pamiętanie o wprowadzaniu zmian w dwóch miejscach, niezbędne jest również czytanie tych samych fragmentów w kilku miejscach.
	\item Długa funkcja - im dłuższa jest funkcja tym jej zrozumienie staje się trudniejsze. Warto dekomponować długie metody na kilka mniejszych stosując ekstrakcję funkcji.
	\item Długa lista parametrów - jeśli funkcja ma wiele parametrów trudniej jest z niej korzystać. Mimo, że współczesne IDE ułatwiają proces wywoływania metod przez wyświetlanie parametrów to funkcje z mniejszą ich liczbą są czytelniejsze. Zmniejszyć listę parametrów można np. przez zebranie funkcji z klasę i stosowanie pól klasy, zamiast parametrów. 
	\item Dane globalne - stosowania zmiennych globalnych czy klas (singletonów) należy unikać, nie wiadomo kiedy i gdzie zostaną one zmienione. Błędy z nimi związane bardzo ciężko się debuguje. 
	\item Dane mutowalne - problem z danymi zmiennymi jest podobny do tego z danymi globalnymi. Tam gdzie to możliwe lepiej jest stosować klasy niezmienne. W C\# od wersji 9.0 można korzystać z rekordów.
	\item Rozbieżne zmiany - powstają w skutek nieprzestrzegania zasady SRP\ref{}. Problemem jest fakt, że wprowadzenie zmiany wymaga modyfikacji w kilku fragmentach kodu, np. zmiana bazy danych pociąga za sobą zmiany w kilku klasach.
	\item Fala uderzeniowa - jest odwrotnością rozbieżnych zmian. ,,Zapach'' powstaje jeżeli jedna zmiana w programie pociąga za sobą konieczność wielu innych zmian, w innych fragmentach kodu. Jest on podobny do rozbieżnych zmian, które odnoszą się do wielu zmian z pojedynczej klasie, natomiast fala uderzeniowa odnosi się do sytuacji kiedy, jedna zmiana jest wykonywana jednocześnie w wielu klasach. 
	\item Zazdrosne funkcjonalności - problem pojawia się, gdy dana metoda odwołuje się w większości do metod z innej klasy. Może to oznaczać, że powinna ona być częścią tej klasy. W takiej sytuacji należy przenieść tę funkcję w miejsce, gdzie bardzie pasuje.
	\item Stada danych - ,,zapach'' powstaje jeśli pola często występują blisko siebie. Pogrupować je można poprzez ekstrakcję do nowej klasy. 
	\item Opętanie typami prostymi - często warto zamiast stosować proste typu: \texttt{int}, \texttt{double}, \texttt{bool} itd. zamienić je własnymi typami. Np. nr telefonu lepiej jest umieścić w osobnej klasie, zamiast stosować łańcuchy znaków.
	\item Powtarzane instrukcje warunkowe - mogą zostać zastąpione polimorfizmem. Klauzule \texttt{if-else} oraz \texttt{swtich-case} często można całkowicie usunąć. W przypadku wielu takich instrukcji warunkowych, może to znacząco poprawić czytelność kodu.
	\item Pętle - zamiast je stosować warto rozważyć użycie potoków. W przypadku C\# dobrym rozwiązaniem jest wykorzystanie wyrażeń LINQ.
	\item Leniwa klasa - ,,zapach'' występuje jeśli klasa nie wykonuje nic ponad delegowanie zadań do innych klas. Ich rola np. mogła się zmniejszyć w wyniku wcześniejszych refaktoryzacji. 
	\item Spekulacyjne uogólnienia - pojawia się jeśli kod jest nadmiarowy, zaprojektowany na przypadki, które być może kiedyś wystąpią, tak na wszelki wypadek.
	\item Pole tymczasowe - przypadek, w którym pewna wartość jest przypisywana do zmiennej tylko w pewnych sytuacjach. Osoba czytająca kod zwykle oczekuje, że obiekt potrzebuje wszystkich swoich zmiennych.
	\item Łańcuchy komunikatów - pojawia się jeśli klient żąda pewnego obiektu, natomiast ten obiekt żąda innego obiektu, a ten inny obiekt jeszcze innego. Każda zmiana struktury nawigacji wymaga zmian w kodzie klienta.
	\item Pośrednik - występuje jeśli dana klasa jedyne co robi to deleguje do innych klas. Zamiast korzystać z tej klasy, często lepiej jest odwołać się bezpośrednio do obiektu, który wie co robić.
	\item Niestosowna bliskość - ma miejsce jeśli dwie klasy wymieniają ze sobą dużą liczbę informacji. Np. jeśli jedna klasa korzysta z klasy danych to być może część tych operacji mogłaby zostać do niej przeniesiona. 
	\item Duża klasa - ,,zapach'' pojawia się jeśli klasa posiada wiele pól, metod czy linii kodu. Często taka klasa powinna zostać podzielona na kilka mniejszych.
	\item Alternatywne klasy z różnymi interfejsami - występuje, gdy dwie klasy, które mogłyby być stosowane zamienne, posiadają różne interfejsy. 
	\item Klasa danych - posiada jedynie pola i metody dostępowe do nich (gettery i settery). Nie posiadają one żadnego dodatkowego zachowania, a klasy kliencie jedynie manipulują na danych z nich zawartych. Wyjątkiem od tej zasady jest oczywiście klasa zwracająca rekord danych.  
	\item Odmowa przyjęcia spadku - ma miejsce, gdy klasy pochodne, korzystają jedynie z części składowych klasy rodzica. Może to świadczyć o źle zaprojektowanej hierarchii klas. Nie zawsze ten ,,zapach'' oznacza coś złego, często można spotkać się z sytuacją w której tworzy się klasę pochodną, aby wykorzystać tylko fragment klasy bazowej. 
\end{itemize}

