\section{Refaktoryzacja}

Refaktoryzacja jest procesem zmiany \textbf{działającego} kodu, bez wpływania na jego zachowanie (kod przed i po refaktoryzacji powinien działać tak samo). Poprawie ulegają jego wewnętrzne struktury. Podczas procesu refaktoryzacji kod powinien być cały czas sprawny. 

Refaktoryzacja powinna być naturalną koleją rzeczy podczas rozwijania oprogramowania. Pozwala na zwiększenie czytelności kodu, jest to szczególnie ważne dla kolegów z zespołu jak i nas samych w przyszłości. Refaktoryzacja polepsza projekt, ułatwia jego modyfikowanie i rozszerzanie. Dodatkowo sprawia, że znalezienie błędów staje się prostsze, a samo programowanie szybsze i sprawniejsze.
% Często jak się zaczyna dany projekt to prace nad nim idą jak burza, dopiero to pewnym czasie następuje stagnacja. Refaktoryzacja pozwala uniknąć tej stagnacji, jeśli projekt jest dobrze rozwijany dodawanie nowych funkcjonalności nie powinno być dużym problemem.  

\subsection{,,Zapachy'' w kodzie}
W kontekście refaktoryzacji często pojawia się słowo ,,zapach'' kodu. ,,Zapaszki'' sugerują miejsca, gdzie w naszym kodzie może dziać się coś złego. Wskazują fragmenty, które potencjalnie powinny zostać podane refaktoryzacji. W~książce Martin Fowler wyróżnia następujące ,,zapachy'':
\begin{itemize}
	\item Tajemnicza nazwa - nazwy metod, klas, pól powinny jasno określać za co dana składowa jest odpowiedzialna. Dzięki narzędziom refaktoryzacyjnym dostępnym w środowiskach IDE, zmiana nazw jest bardzo prosta i warto z niej często korzystać.
	\item Zduplikowany kod - jeśli fragment kodu pojawia się w dwóch miejscach jego utrzymanie staje się trudne. Konieczne jest pamiętanie o wprowadzaniu zmian w dwóch miejscach, niezbędne jest również czytanie tych samych fragmentów w kilku miejscach.
	\item Długa funkcja - im dłuższa jest funkcja tym jej zrozumienie staje się trudniejsze. Warto dekomponować długie metody na kilka mniejszych stosując ekstrakcję funkcji.
	\item Długa lista parametrów - jeśli funkcja ma wiele parametrów trudniej jest z niej korzystać. Mimo, że współczesne IDE ułatwiają proces wywoływania metod przez wyświetlanie parametrów to funkcje z mniejszą ich liczbą są czytelniejsze. Zmniejszyć listę parametrów można np. przez zebranie funkcji z klasę i stosowanie pól klasy, zamiast parametrów. 
	\item Dane globalne - stosowania zmiennych globalnych czy klas (singletonów) należy unikać, nie wiadomo kiedy i gdzie zostaną one zmienione. Błędy z nimi związane bardzo ciężko się debuguje. 
	\item Dane mutowalne - problem z danymi zmiennymi jest podobny do tego z danymi globalnymi. Tam gdzie to możliwe lepiej jest stosować klasy niezmienne. W C\# od wersji 9.0 można korzystać z rekordów.
	\item Rozbieżne zmiany - powstają w skutek nieprzestrzegania zasady SRP\ref{}. Problemem jest fakt, że wprowadzenie zmiany wymaga modyfikacji w kilku fragmentach kodu, np. zmiana bazy danych pociąga za sobą zmiany w kilku klasach.
	\item Fala uderzeniowa - jest odwrotnością rozbieżnych zmian. ,,Zapach'' powstaje jeżeli jedna zmiana w programie pociąga za sobą konieczność wielu innych zmian, w innych fragmentach kodu. Jest on podobny do rozbieżnych zmian, które odnoszą się do wielu zmian z pojedynczej klasie, natomiast fala uderzeniowa odnosi się do sytuacji kiedy, jedna zmiana jest wykonywana jednocześnie w wielu klasach. 
	\item Zazdrosne funkcjonalności - problem pojawia się, gdy dana metoda odwołuje się w większości do metod z innej klasy. Może to oznaczać, że powinna ona być częścią tej klasy. W takiej sytuacji należy przenieść tę funkcję w miejsce, gdzie bardzie pasuje.
	\item Stada danych - ,,zapach'' powstaje jeśli pola często występują blisko siebie. Pogrupować je można poprzez ekstrakcję do nowej klasy. 
	\item Opętanie typami prostymi - często warto zamiast stosować proste typu: \texttt{int}, \texttt{double}, \texttt{bool} itd. zamienić je własnymi typami. Np. nr telefonu lepiej jest umieścić w osobnej klasie, zamiast stosować łańcuchy znaków.
	\item Powtarzane instrukcje warunkowe - mogą zostać zastąpione polimorfizmem. Klauzule \texttt{if-else} oraz \texttt{swtich-case} często można całkowicie usunąć. W przypadku wielu takich instrukcji warunkowych, może to znacząco poprawić czytelność kodu.
	\item Pętle - zamiast je stosować warto rozważyć użycie potoków. W przypadku C\# dobrym rozwiązaniem jest wykorzystanie wyrażeń LINQ.
	\item Leniwa klasa - ,,zapach'' występuje jeśli klasa nie wykonuje nic ponad delegowanie zadań do innych klas. Ich rola np. mogła się zmniejszyć w wyniku wcześniejszych refaktoryzacji. 
	\item Spekulacyjne uogólnienia - pojawia się jeśli kod jest nadmiarowy, zaprojektowany na przypadki, które być może kiedyś wystąpią, tak na wszelki wypadek.
	\item Pole tymczasowe - przypadek, w którym pewna wartość jest przypisywana do zmiennej tylko w pewnych sytuacjach. Osoba czytająca kod zwykle oczekuje, że obiekt potrzebuje wszystkich swoich zmiennych.
	\item Łańcuchy komunikatów - pojawia się jeśli klient żąda pewnego obiektu, natomiast ten obiekt żąda innego obiektu, a ten inny obiekt jeszcze innego. Każda zmiana struktury nawigacji wymaga zmian w kodzie klienta.
	\item Pośrednik - występuje jeśli dana klasa jedyne co robi to deleguje do innych klas. Zamiast korzystać z tej klasy, często lepiej jest odwołać się bezpośrednio do obiektu, który wie co robić.
	\item Niestosowna bliskość - ma miejsce jeśli dwie klasy wymieniają ze sobą dużą liczbę informacji. Np. jeśli jedna klasa korzysta z klasy danych to być może część tych operacji mogłaby zostać do niej przeniesiona. 
	\item Duża klasa - ,,zapach'' pojawia się jeśli klasa posiada wiele pól, metod czy linii kodu. Często taka klasa powinna zostać podzielona na kilka mniejszych.
	\item Alternatywne klasy z różnymi interfejsami - występuje, gdy dwie klasy, które mogłyby być stosowane zamienne, posiadają różne interfejsy. 
	\item Klasa danych - posiada jedynie pola i metody dostępowe do nich (gettery i settery). Nie posiadają one żadnego dodatkowego zachowania, a klasy kliencie jedynie manipulują na danych z nich zawartych. Wyjątkiem od tej zasady jest oczywiście klasa zwracająca rekord danych.  
	\item Odmowa przyjęcia spadku - ma miejsce, gdy klasy pochodne, korzystają jedynie z części składowych klasy rodzica. Może to świadczyć o źle zaprojektowanej hierarchii klas. Nie zawsze ten ,,zapach'' oznacza coś złego, często można spotkać się z sytuacją w której tworzy się klasę pochodną, aby wykorzystać tylko fragment klasy bazowej. 
\end{itemize}

\subsubsection{Zadanie 1}
Przeprowadź refaktoryzację poniższej metody:
\begin{lstlisting}[caption={Metoda \texttt{Statement}}]
static string Statement(Invoice invoice, Dictionary<string, Play> plays)
{
	var totalAmount = 0;
	var volumeCredits = 0;
	var results = $"Rachunek dla {invoice.customer}";
	
	CultureInfo pl = new CultureInfo("pl-PL");
	
	foreach (var perf in invoice.performance)
	{
		var play = plays[perf.playID];
		var thisAmount = 0;
		
		switch (play.Type)
		{
			case "tragedia":
			thisAmount = 40000;
			if (perf.audience > 30)
			{
				thisAmount += 1000 * (perf.audience - 30);
			}
			break;
			case "komedia":
			thisAmount = 30000;
			if (perf.audience > 20)
			{
				thisAmount += 10000 + 500 * (perf.audience - 20);
			}
			thisAmount += 300 * perf.audience;
			break;
			default:
			throw new ArgumentException($"Nieznany typ przedstawienia: ${play.Type}");
		}
		
		// Award bonus points
		volumeCredits += Math.Max(perf.audience - 30, 0);
		// Award an additional promotional point for every 5 viewers of the comedy
		if ("komedia" == play.Type)
		{
			volumeCredits += (int)Math.Floor((decimal)perf.audience / 5);
		}
		
		// Create statement row
		results += $"{play.Name}: {(thisAmount / 100).ToString("c", pl)} (liczba miejsc: {perf.audience}" + Environment.NewLine;
		totalAmount += thisAmount;
	}
	
	results += $"Naleznosc: {(totalAmount / 100).ToString("c", pl)}" + Environment.NewLine;
	results += $"Punkty promocyjne: {volumeCredits}";
	
	return results;
}
\end{lstlisting}
,gdzie:
\begin{lstlisting}[caption={plays.json}]
{
	"hamlet": {
		"Name": "Hamlet",
		"Type": "tragedia"
	},
	"as-like": {
		"Name": "Jak wam sie podoba",
		"Type": "komedia"
	},
	"othello": {
		"Name": "Otello",
		"Type": "tragedia"
	}
}
\end{lstlisting}
oraz
\begin{lstlisting}[caption={invoices.json}]
{
	"customer": "BigCo",
	"performance": [
	{
		"playID": "hamlet",
		"audience": 55
	},
	{
		"playID": "as-like",
		"audience": 35
	},
	{
		"playID": "othello",
		"audience": 40
	}
	]
}
\end{lstlisting}

Dodaj do projektu trzy pliki z następującymi deklaracji klas:
\begin{lstlisting}[caption={Performance.cs}]
public class Performance
{
	[JsonProperty("playID")]
	public string PlayID { get; set; }
	[JsonProperty("audience")]
	public int Audience { get; set; }
}
\end{lstlisting}
\begin{lstlisting}[caption={Invoice.cs}]
public class Invoice
{
	[JsonProperty("customer")]
	public string Customer { get; set; }
	[JsonProperty("performance")]
	public List<Performance> Performance { get; set; }
}
\end{lstlisting}
oraz
\begin{lstlisting}[caption={Play.cs}]
public class Play
{
	[JsonProperty("name")]
	public string Name { get; set; }
	[JsonProperty("type")]
	public string Type { get; set; }
}
\end{lstlisting}

Sprawdź zwracany wynik funkcji \texttt{Statement} w metodzie \texttt{Main}:
\begin{lstlisting}[caption={Play.cs}]
static void Main(string[] args)
{
	Dictionary<string, Play> plays = JsonConvert.DeserializeObject<Dictionary<string, Play>>(File.ReadAllText(@".\plays.json"));
	Invoice invoice = JsonConvert.DeserializeObject<Invoice>(File.ReadAllText(@".\invoices.json"));
	
	Console.WriteLine(Statement2(invoice, plays));
}
\end{lstlisting}

W pierwszym kroku dokonaj ekstrakcji wyrażenia \texttt{switch} zaznaczając całe wyrażenie i wciskając \texttt{Alt+Enter} i wybierając opcję \texttt{Extract local function}, nazwij tę funkcję \texttt{AmountFor}. Zamiast tworzyć zmienną \texttt{thisAmount} i przypisywać jej najpierw wartość zero, przypisz jej od razu zwracaną wartość przez \texttt{AmountFor}. Zmień za pomocą \texttt{Alt+Enter} nazwę zmiennej \texttt{thisAmount} na nazwę bardziej odpowiednią informującą, że jest to wartość zwracana przez tę funkcję. Parametr \texttt{perf} również nie jest jasny, zmień go na bardziej opisowy.

Wewnątrz metody \texttt{Statement} dodaj funkcję lokalną:
\begin{lstlisting}[caption={Dodanie wyrażenia \texttt{GetPlay}}]
static string Statement(Invoice invoice, Dictionary<string, Play> plays)
{
	//...
	Play GetPlay(Performance perf) => plays[perf.PlayID];	
}
\end{lstlisting}

Wykonaj wchłonięcie funkcji, zmieniając wszystkie wykorzystania zmiennej \texttt{play} na wywołanie metody \texttt{GetPlay(perf)}. Usuń zmienną \texttt{play}. Analogicznie usuń parametr lokalnej funkcji \texttt{AmountFor}, wykonując zmianę deklaracji funkcji. Możesz w tym celu wykorzystać narzędzie refaktoryzacyjne w Visual Studio. 

Refaktoryzację Wchłonięcie Zmiennej wykonaj również dla \texttt{thisAmount}, zamień ją wywołaniem funkcji lokalnej \texttt{AmountFor}. Usuń zmienną \texttt{thisAmount}.

Wyodrębnij fragment kodu odpowiedzialny za liczenie rabatu:
\begin{lstlisting}
static string Statement(Invoice invoice, Dictionary<string, Play> plays)
{
	//...
	int VolumeCreditsFor(Performance perf)
	{
		var valumeCredits = 0;
		// Award bonus points
		valumeCredits += Math.Max(perf.Audience - 30, 0);
		// Award an additional promotional point for every 5 viewers of the comedy
		if ("komedia" == GetPlay(perf).Type)
		{
			valumeCredits += (int)Math.Floor((decimal)perf.Audience / 5);
		}
		
		return valumeCredits;
	}	
}
\end{lstlisting}
Dokonaj zmian w pętli \texttt{foreach} tak, aby do zmiennej \texttt{volumeCredits} była dodawana wartość zwracana przez funkcję \texttt{VolumeCreditsFor}. Zmień nazwy zmiennych wewnątrz funkcji \texttt{VolumeCreditsFor} na bardziej opisowe. 


Analogicznie wyodrębnij funkcję formatującą waluty:
\begin{lstlisting}
static string Statement(Invoice invoice, Dictionary<string, Play> plays)
{
	//...
	string FormatAsPLN(int aNumber) => (aNumber/100).ToString("c", new CultureInfo("pl-PL"));
}	

\end{lstlisting}
oraz zmień miejsca, gdzie były formatowane waluty na wywołanie lokalnej funkcji \texttt{FormatAsPLN}.

Teraz, aby wchłonąć zmienną \texttt{volumeCredits} zastosuj Podział pętli. 
\begin{lstlisting}
static string Statement(Invoice invoice, Dictionary<string, Play> plays)
{
	//...	
	
	foreach (var perf in invoice.Performance)
	{
		// Create statement row
		results += $"{GetPlay(perf).Name}: {PolishZloty((AmountFor(perf)))} (liczba miejsc: {perf.Audience}" + Environment.NewLine;
		totalAmount += AmountFor(perf);
	}
	
	foreach (var perf in invoice.Performance)
	{
		volumeCredits += VolumeCreditsFor(perf);
	}
	
	//...
}
\end{lstlisting}
Następnie przenieś pętle w której wykonywane jest liczenie rabatu to osobnej funkcji lokalnej wraz ze zmienną lokalną \texttt{volumeCredits}. Teraz usuń w funkcji \texttt{Statement} zmienną \texttt{volumeCredits} i w miejscu jej użycia umieść wywołanie utworzonej przed chwilą funkcji lokalnej. Wykonaj analogiczną refaktoryzację ze zmienną \texttt{totalAmount}.



